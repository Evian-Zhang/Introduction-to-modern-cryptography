% !TEX root = ../../现代密码学简介.tex
\chapter{公钥密码}
\section{简介}
之前我们讲到，最安全的密码体系是一次一密。但是，由于其需要用安全信道传输的密钥长度至少于明文一样长，并且一个密钥只能用一次，因此，与其将密钥传输，不如将明文传输。所以，一次一密的缺陷也十分明显。为了解决这一问题，之前我们采取的方法是使用各种手法，包括流密码以及分组密码等，来缩短密钥的长度。\par
此外，在之前谈到的对称密码体系中，如果一个系统中有$n$个人要进行加密通信。那么，为了保障安全性，每一次通信的过程中都要使用独一无二的密钥。因此，一共需要$\ext C_n^2=\frac{n\pth{n-1}}{2}$个密钥。\par
公钥密码体系则可以解决这两个问题，其基本思想为:
\begin{enumerate}
	\item 由解密方生成一对密钥，称为公钥（记作$SK$）和私钥（记作$PK$）。
	\item 解密方将公钥传送给加密方（不需要通过安全信道）。
	\item 加密方利用公钥加密明文，传递给解密方。
	\item 解密方利用私钥解密密文。
\end{enumerate}

因此，和之前讲到的对称密码体系类似，公钥密码体系包含的三个关键算法是：公钥-私钥生成算法，加密算法，解密算法。\par
要在实践中实现这个思想，我们得满足：
\begin{itemize}
	\item 生成公钥、密钥对的算法较容易
	\item 用公钥加密明文的算法较容易
	\item 用密钥解密密文的算法较容易
	\item 由公钥不能（或者很难）得到对应的密钥
	\item 由密文和公钥不能（或者很难）得到对应的明文
	\item 公钥、私钥可交换。即：
	\begin{equation}
	\D{PK}{\E{SK}{m}} = \D{SK}{\E{PK}{m}}
	\end{equation}
\end{itemize}

上述的六个要求，实质上就是需要我们找到如下的一种“单向陷门函数”$f(x)$:\par
对于从$X$到$Y$的函数$f(x)$, 如果$\forall x\in X$, $f(x)$的计算较容易，而对于几乎所有$Y$中的元素$y$, 找出其对应的$x$都是计算不可行的。但是，如果掌握一个“陷门”$z$, 则求逆较容易。则称$f(x)$为一个单向陷门函数。\par
比如说将一个怀表拆成许多零件是容易的，将零件重新装回一个怀表是几乎不可能的。但如果我们拥有怀表的构造说明书，那么用零件装回怀表又是较容易的。这就是现实中的一个单项陷门函数。\par
如果我们找到了这样一种单向陷门函数，那么我们可以用它来构造公钥。\par
但是，这个定义中，“较容易”、“几乎所有”、“计算不可行”都是一种直观上的感性词语。其真正的严格数学定义需要用到概率多项式时间等高深的方法，这里不再介绍。\par
此外，公钥密码体系还有一个重要的特点是，其安全性基于数论知识，而非类似于分组密码的代换与替换。并且，在之后的算法细节中我们会了解到，公钥密码体系的算法比对称密码体系的算法要慢许多。同时，由于并非一次一密，因此其安全性从本质上说并不比对称密码体系高。\par
公钥密码体系也称为非对称密码体系，因为用于加密的公钥不能解密其密文。\par
同时，公钥密码除了解决了密钥分配问题，即对安全信道的需求问题，其还解决了另外一个问题：数字签名问题。即，在以往的对称加密体系中，我们无法得知收到的密文是否来自于我们选择的加密方。
\section{RSA密码}
在现在的互联网安全中，RSA密码体系承担了大部分的工作。如Outlook等加密邮件都是使用RSA的密码体系。
\subsection{基本框架}
之前讲到，公钥密码体系包括公钥-私钥生成算法，加密算法和解密算法。下面介绍其基本框架。值得指出的是，这里只是写了其操作步骤，而没有说明其具体实现方法。具体的实现方法会在后面再介绍。
\subsubsection{公钥-私钥生成算法}
\begin{enumerate}
\item 取两个素数$p, q$, 且$p\neq q$
\item 计算$n=pq$和$\varphi(n)=\pth{p-1}\pth{q-1}$
\item 取$e$, 使得$1<e<\varphi(n)$且$\pth{\varphi\pth{n}, e}=1$, 即$\varphi(n)$与$e$互素
\item 计算$d$, 使得$d$满足
\begin{equation}
de\equiv 1\pmod{\varphi(n)}
\end{equation}
\item 公钥为$\pth{e, n}$, 私钥为$\pth{d, n}$.
\end{enumerate}
\subsubsection{加密算法}
对于公钥$\pth{e, n}$, 加密者需要加密的二进制字符串对应的二进制数为$m$. 要求$m<n$. 加密操作为
\begin{equation}
c= m^e\bmod{n}
\end{equation}

再将每个$c$拼起来形成密文串。
\subsubsection{解密算法}
对于私钥$\pth{d, n}$, 解密者将接收到的密文$c$作解密操作
\begin{equation}
m= c^d\bmod{n}
\end{equation}
\subsection{算法细节}
上一小节讨论了RSA的整体算法结构。接下来，分几个部分介绍一下具体的算法细节。
\subsubsection{大整数}
在RSA中，需要使用到许多大整数。这些大整数规模在1024比特左右。因此，我们在程序实现时，采用一个大整数类\verb`BigInteger`, 其将大整数以二进制串的形式存储，成员变量为符号位\verb`sign`(布尔值，非负为\verb`true`)，二进制串长度\verb`length`, 以及由低位向高位存储的二进制串\verb`value`.
\subsubsection{大整数相乘模运算}
最常用的运算是求两个大整数的乘积对于另一个大整数的模。为了使中间结果的位数不太大，我们可以考虑如下结论：\par
若$\ext a=\sum_{i=0}^na_i2^i$, 那么
\begin{equation}
ab\bmod{c}=\sum_{i=0}^n\pth{a_ib2^i\bmod{c}}
\end{equation}

比如说，如果$\ext a=\pth{1001}_2=2^3+2^0$, 那么
\[
ab\bmod{c}=\pth{2^3b\bmod{c}}+\pth{2^0b\bmod{c}}
\]

利用这种想法，其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger mulmod(const BigInteger mul1,
                  const BigInteger mul2, const BigInteger mod)
{
    if (mul1 == 0 || mul2 == 0)
        return 0;
    
    BigInteger product = 0;
    BigInteger modMul1 = mul1;
    for (int digit = 0; digit < mul2.length; digit++)
    {
        modMul1 = (modMul1 << 1) % mod;
        if (mul2.value[digit])
            product = (product + modMul1) % mod;
    }
    
    return product;
}
\end{verbatim}
\end{prove}
\subsubsection{大整数幂模运算}
此外，还有一个常用的运算是对于大整数$a, b, c$, 求$a^b\bmod{c}$. 这里常用的方法为快速指数法。其基本思想为：\par
假设$b$的二进制表示为$b_kb_{k-1}\cdots b_0$, 即
\begin{equation}
b=b_k2^k+b_{k-1}2^{k-1}+\cdots +2b_1+b_0
\end{equation}

那么
\begin{equation}
a^b=\pth{\cdots \pth{\pth{a^{b_k}}^2a^{b_{k-1}}}^2\cdots a^{b_{1}}}^2a^{b_0}
\end{equation}

比如说，如果$b=9$, 那么我们可以
\[a^b\bmod{c}=a^{8+1}\bmod{c}=\pth{\pth{a^2}^2}^2\cdot a\bmod{c}\]

将原本需要算9次的乘法改进成算4次。此外，我们还可以每一次乘法都求模，这样可以使中间结果更小，如：\par
$\ext b=\pth{1001}_2=2^3+2^0$, 那么
\[
a^b\bmod{c}=\pth{\pth{\pth{a^2\bmod{c}}^2\bmod{c}}^2\bmod{c}}\cdot a
\]

其C程序实现为：
\begin{prove}
\begin{verbatim}
BigInteger fastExp(const BigInteger base,
                   const BigInteger exponent,
                   const BigInteger mod)
{
    BigInteger power = 1;
    
    for (int digit = exponent.length - 1; digit >= 0; digit--)
    {
        power = mulmod(power, power, mod);
        if (exponent.value[digit])
            power = mulmod(power, base, mod);
    }
    
    return power;
}
\end{verbatim}
\end{prove}
\subsubsection{互素判定}
判断两个数是否互素，我们常用欧几里德辗转相除法求两个数的最大公因数。其基本原理为
\begin{theorem}
对于整数$a, b$
\begin{equation}
\pth{a, b}=\pth{b, a\bmod{b}}
\end{equation}
\end{theorem}

其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger gcd(BigInteger a, BigInteger b)
{
    if (a % b == 0)
        return b;
    return gcd(b, a % b);
}
\end{verbatim}
\end{prove}
\subsubsection{求乘法逆元}
由裴蜀定理可知，对于整数$x, y$, 存在整数$a, b$, 使得
\begin{equation}
ax+by=\pth{x, y}
\end{equation}

那么，如果$\pth{x,y} = 1$, 那么存在整数$a, b$, 使得
\begin{equation}
ax+by=1
\end{equation}
因此
\[ax=-by+1\]

故
\begin{equation}
ax\equiv 1\pmod{y}
\end{equation}

因此，我们如果可以由$x, y$找出对应的$a, b$, 那么$a$就是$x$模$y$的乘法逆元。\par
因此，我们使用扩展欧几里德算法。其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger extendGcd(BigInteger x, BigInteger y,
                     BigInteger &a, BigInteger &b)
{
    if (y == 0)
    {
        a = 1;
        b = 0;
        return x;
    }
    
    BigInteger r = extendGcd(y, x % y, a, b);
    BigInteger tmp = a;
    a = b;
    b = tmp - x / y * b;
    return r;
}
\end{verbatim}
\end{prove}

从而，求乘法逆元的C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger inverse(const BigInteger a, const BigInteger mod)
{
    BigInteger inverse = 0;
    BigInteger tmp = 0;
    extendGcd(a, mod, inverse, tmp);
    return (inverse % mod + mod) % mod;
}
\end{verbatim}
\end{prove}
\subsubsection{素数$p, q$的选取}
在之后会介绍，RSA的安全性取决于$p, q$要是大素数。那么，我们就需要判断素数。最初等的方法是从$3$到$\sqrt{n}$挨个判断是否是$n$的因子。但是对于极大的数，这样判断方法是不现实的。因此，下面介绍一下常用的判断素数的方法：Miller-Rabin素数测试。\par
Miller-Rabin素数测试基于一个基本定理：
\begin{theorem}
对于奇数$n=2^sd+1$, 其中$d$为奇数。若存在$a$满足$\forall 0\leq r\leq s-1$, 有
\begin{gather}
a^d\not\equiv 1\pmod{n}\\
a^{2^rd}\not\equiv 1\pmod{n}
\end{gather}

则$p$不是素数。
\end{theorem}

由此定理，我们取充分多的$a$, 对于每个$a$我们测试所有的$0\leq r\leq s-1$, 只要有一个不满足，那么$p$就不是素数。如果我们取的$a$充分多，并且都没有找到不满足定理的值，那么$p$就可以被看作一个素数。\par
那么，我们取多少个$a$比较合适呢？事实上，如果奇数$n$是$k$位二进制数，并对它进行$t$次Miller-Rabin测试均返回成功，那么其为合数的概率满足
\begin{equation}
P<\begin{dcases}k^24^{2-\sqrt{k}}&k\geq 2\\k^{\frac{3}{2}}2^tt^{-\frac{1}{2}}4^{2-\sqrt{tk}}&y=2, k\geq 88\text{或}3\leq t\leq \frac{k}{9}, k\geq 21\\\frac{7}{20}k2^{-5t}+\frac{1}{7}k^{-\frac{k}{2}-2t}+12k2^{-\frac{k}{4}-3t}&t\geq\frac{k}{9}, k\geq 21\\\frac{1}{7}k^{\frac{15}{4}}2^{-\frac{k}{2}-2t}&t\geq \frac{k}{4}, k\geq 21\end{dcases}
\end{equation}

对于$1024$比特的$n$, 选取$40$个$a$以后$n$为合数的概率要小于$2^{-83}$. 而事实上，我们也常对$n$使用40次Miller-Rabin测试。
其C程序实现如下：
\begin{prove}
\begin{verbatim}
bool Miller_Rabin(BigInteger n, int round)
{
    BigInteger m = n - 1;
    int k = 0;
    while (!m.getValue()[0])
    {
        k++;
        m = m >> 1;
    }
    
    for (int i = 0; i < round; i++)
    {
        BigInteger a = BigInteger::getRand() % (n - 1) + 1;
        BigInteger b = BigInteger::fastExp(a, m, n);
        if (b == 1)
            return true;
        
        for (int j = 0; j < k; j++)
        {
            if (b == n - 1)
                return true;
            b = BigInteger::mulmod(b, b, n);
        }
    }
    return false;
}
\end{verbatim}
\end{prove}

上述讲的是如何测试$p, q$是否为素数。那么如何生成$p, q$呢？常用的方法是：\par
随机生成一个1024比特的奇数，然后对其进行40轮Miller-Rabin测试。如果不是素数，则将其自增2.\par
看似这个方法很没有效率，但是，根据素数定理，在$0$到$N$之间，每两个相邻的素数之间的平均距离为$\ln N$. 因此，对于1024比特的奇数$n$, 如果其不为素数，那么其前后两个素数之间的距离约为$\ln n$. 故其平均需要再往后测试
\[\frac{\ln n}{2}\approx 354\]

次即可。\par
综上，公钥-私钥对的产生的C程序算法如下：
\begin{prove}
\begin{verbatim}
void generateKeys(BigInteger &pub, BigInteger &pri)
{
    pub = getRandBit(1024);
    if (!pub.getValue()[0])
        pub += 1;
    
    while (!Miller_Rabin(pub, 40))
        pub += 2;
    
    
    pri = getRandBit(1024);
    if (!pri.getValue()[0])
        pri += 1;
    
    while (!Miller_Rabin(pri, 40))
        pri += 2;
}
\end{verbatim}
\end{prove}
\subsubsection{$e$的选取}
由于RSA算法的安全性主要在于$p, q$的选取，因此，作为公钥的$e$的选取就没有必要是随机的。常用的$e$取自$3,5,17,257,65537$. 判断$e$与$\varphi(n)=\pth{p-1}\pth{q-1}$是否互素可以用欧几里德辗转相除法\verb`gcd()`来求其最大公因数，判断其是否为$1$.\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger generateE(BigInteger phi)
{
    BigInteger list[5] = {65537, 257, 17, 5, 3};
    for (int i = 0; i < 5; i++)
        if (BigInteger::gcd(phi, list[i]) == 1)
            return list[i];
    
    return -1;
}
\end{verbatim}
\end{prove}
\subsubsection{$d$的求值}
由定义，$d$是$e$模$\varphi(n)$的乘法逆元。因此，我们采用扩展欧几里德算法求$d$.
\subsubsection{加密}
RSA的加密过程实际上就是求大整数的幂的模。因此，我们可以采用快速指数法。
\subsubsection{解密}
RSA的解密过程是解密方进行的操作。而解密方拥有的数有$p, q, n, \varphi(n), e, d$以及密文$c$.\par
解密方可计算
\begin{equation}
\begin{dcases}d_p=d\bmod{\pth{p-1}}\\d_q=d\bmod{q-1}\end{dcases}, \begin{dcases}m_p=c^{d_p}\bmod{p}\\m_q=c^{d_q}\bmod{q}\end{dcases}
\end{equation}

于是由费马小定理可化简得到
\[\begin{dcases}m_p\equiv m\pmod{p}\\m_q\equiv m\pmod{q}\end{dcases}\]

运用中国剩余定理:
\begin{equation}
m\equiv qe_pm_p+pe_qm_q\pmod{pq}
\end{equation}

其中$qe_p\equiv 1\pmod{p}, pe_q\equiv 1\pmod{q}$.\par
如果我们采用快速指数法计算$m_p, m_q$, 采用扩展欧几里德算法计算$e_p, e_q$, 即可得到$m$.\par
其C程序实现如下：
\begin{prove}
\begin{verbatim}
BigInteger RSA_DEC(BigInteger cipher, BigInteger d,
                   BigInteger p, BigInteger q)
{
    BigInteger dp = d % (p - 1);
    BigInteger dq = d % (q - 1);
    
    BigInteger mp = fastExp(cipher, dp, p);
    BigInteger mq = fastExp(cipher, dq, q);
    
    BigInteger ep = inverse(q, p);
    BigInteger eq = inverse(p, q);
    
    BigInteger n = p * q;
    
    BigInteger tmp1 = mulmod(q, ep, n);
    tmp1 = mulmod(tmp1, mp, n);
    
    BigInteger tmp2 = mulmod(p, eq, n);
    tmp2 = mulmod(tmp2, mq, n);
    
    return tmp1 + tmp2;
}
\end{verbatim}
\end{prove}
\subsection{RSA的数学验证}
接下来，用数论知识验证RSA算法的正确性，即对于任意符合条件的明文，有
\begin{equation}
\D{\pth{d, n}}{\E{\pth{e, n}}{m}}=m
\end{equation}

\begin{prove}
由
\[c=m^e\bmod{n}\]
以及
\[ed\equiv 1\pmod{\varphi(n)}\]
可知
\begin{equation}
c^d\equiv m^{ed}\equiv m^{k\varphi(n)+1}\pmod{n}
\end{equation}

下面分两种情况讨论：
\begin{enumerate}
	\item 若$\pth{m, n} = 1$.\par
	则由欧拉定理可知
	\[m^{k\varphi(n)+1}\equiv \pth{m^\varphi(n)}^km\equiv 1^km\equiv m\pmod{n}\]
	故
	\[c^d\equiv m\pmod{n}\]
	\item 若$\pth{m, n}=g>1$\par
	则$g\mid n=pq$, 故$g=p$或$g=q$. 又$g\mid m$, 故$m$是$p$或$q$的倍数。不妨设$m=tp$, 则$\pth{m, q}=1$. 故
	\begin{align*}
	&m^{k\varphi(n)}\equiv\pth{m^{k\varphi(q)}}^{\varphi(p)}\\
	\equiv&1^{\varphi(p)}\equiv 1\pmod{q}
	\end{align*}

	故
	\[m^{k\varphi(n)}=1+rq\]
	从而
	\[m^{k\varphi(n)+1}=m+mrq=m+rtpq=m+rtn\]
	故
	\[c^d\equiv m\pmod{n}\]
\end{enumerate}
\end{prove}
\subsection{RSA的安全性}
根据以上的讨论，本小节论述RSA的安全性。\par
首先，如果攻击者知道了素数$p, q$, 那么由公钥就很容易得到私钥（用扩展欧几里德算法），从而破解RSA.\par
事实上，如果要破解RSA，即获得私钥$d$, 那么就需要由$n$求得$\varphi(n)$, 然后用扩展欧几里德算法求私钥。如果攻击者通过某种方法，由$n$求得了$\phi(n)$, 那么由数论知识可以得到
\[\begin{dcases}p+q=n-\varphi(n)+1\\p-q=\sqrt{\pth{n-\varphi(n)+1}^2-4n}\end{dcases}\]
故如果求得$n$和$\varphi(n)$, 那么等价于求得$p$和$q$.\par
因此，破解RSA就等价于因数分解大整数。
\section{ElGamal密码}
\subsection{数学基础}
使用ElGamal密码，首先需要有一定的抽象代数基础。下面简单介绍几个术语：\par
对于群$G$及$G$上的运算$\cdot$, 将$n$个$g$相运算$g\cdot g\cdot \cdots \cdot g$的结果记作$g^n$.\par
如果存在一个元素$g\in G$, 使得对于任意元素$x\in G$, 存在$n$使得$a=g^n$, 则称$G$为循环群，$g$为$G$的生成元。\par
如果$G$的元素有$q$个，则称$G$是$q$阶的。
\subsection{基本框架}
和RSA类似，ElGamal密码的三个基本步骤为公钥-私钥生成、加密、解密。
\subsubsection{公钥-私钥生成}
\begin{enumerate}
	\item 选择一个生成元为$g$的$p$阶循环群$G$
	\item 选择一个$0$到$p-1$的整数$x$
	\item 计算$y=g^x$
	\item 将$\pth{G, p, g, y}$作为公钥，$x$作为私钥
\end{enumerate}
\subsubsection{加密}
对于明文$m$和公钥$\pth{G, p, g, y}$, 加密者需要做的是
\begin{enumerate}
	\item 选择一个$0$到$p-1$的整数$k$
	\item 计算$C_1=g^k, s=y^k$
	\item 将$m$映射到$G$上的一个元素$m'$
	\item 计算$C_2=m'\cdot s=m'\cdot y^k$
	\item 密文为$\pth{C_1, C_2}$
\end{enumerate}

在加密过程中，第3步将$m$映射到$G$上的一个元素$m'$是一个可以定制的过程，对于不同描述方法的群$G$, 有不同的映射方法，因而导致了ElGamal可以使用多种密码体制。\par
此外，在加密过程中我们也可以发现，ElGamal体系有一个缺点：密文长度是明文的两倍。\par

\subsubsection{解密}
对于密文$\pth{C_1, C_2}$和私钥$x$, 解密者需要做的是
\begin{enumerate}
	\item 计算$s=C_1^x$
	\item 计算$m'=C_2\cdot s^{-1}$
	\item 将$m'$映射回$m$即为明文
\end{enumerate}
\subsection{正确性证明}
需要证明ElGamal密码的正确性，只需要证明解密者第一步计算$s=C_1^x$得到的$s$即为加密者的$s$. 而
\[C_1^x=\pth{g^k}^x=\pth{g^x}^k=y^k=s\]

从而证明了ElGamal密码的正确性。
\subsection{ElGamal密码的安全性}
通过对ElGamal密码的算法介绍，我们可以发现，其安全性，也就是由公钥无法推出私钥，是建立在已知$y=g^x$中的$y$和$g$, 却无法得到$x$的问题。这个问题被称作离散对数问题。
\subsection{模$n$整数乘法群上的ElGamal}
ElGamal密码体系由于循环群$G$的选取不同而可以产生许多不同的加密方法。而数论知识告诉我们，对于奇素数的幂$n=p^k$, 模$n$整数乘法群$\Z/n\Z=\{m\mid\pth{m, n}=1, 0\leq m\leq n-1\}$构成一个循环群。\par
那么，在模$n$整数乘法群上的ElGamal密码体系即为：
\subsubsection{公钥-私钥生成}
\begin{enumerate}
	\item 选取素数$p$, 构成模$p$整数乘法群$\Z/p\Z$, 选取其一个生成元$g$
	\item 在$1$到$p-1$中选一个数$x$
	\item 计算$y=g^x\bmod{p}$
	\item 公钥为$\pth{p, g, y}$, 私钥为$x$
\end{enumerate}
\subsubsection{加密}
假设明文对应的二进制数为$m$
\begin{enumerate}
	\item 在$1$到$p-1$中选一个数$k$
	\item 计算$C_1=g^k\bmod{p}, s=y^k\bmod{p}$
	\item 计算$C_2=m\cdot s\bmod{p}=m\cdot y^k\bmod{p}$
	\item 密文为$\pth{C_1, C_2}$
\end{enumerate}
\subsubsection{解密}
假设密文为$\pth{C_1, C_2}$
\begin{enumerate}
	\item 计算$s=C_1^x\bmod{p}$
	\item 计算$m=C_2\cdot s^{-1}\bmod{p}$, 即为明文
\end{enumerate}
\subsection{椭圆曲线}
在常用的ElGamal密码中，$G$常被描述成有限域上的椭圆曲线上的点构成的群。其定义为：
\begin{equation}
E_p\pth{a, b}=\brace{\pth{x, y}\mid y^2\equiv x^3+ax+b\pmod{p}, 0\leq x\leq p-1, 0\leq y\leq p-1}\cup \brace{O}
\end{equation}

其中
\[a,b\in\GF\pth{p}, 4a^3+27b^2\neq 0\]
而$O$为加法单位元，意义是无限远点。\par
其上的加法$+$的定义为：\par
对于$E_p\pth{a, b}$的元素$A(x_1, y_1)$和$B(x_2, y_2)$, 若两者相异，$A+B$表示穿过$A$和$B$的弦和椭圆曲线相交的第三点，再经$x$轴反射的镜像点；若两者是同一点，$A+A$表示以$A$为切点和椭圆曲线相交的点再经$x$轴反射的镜像点。若$A$和$B$的弦与$y$轴平行，$A+B=O$（无限远点）。\par
同时，也可以用代数方式定义加法：\par
对于$E_p\pth{a, b}$的元素$A(x_1, y_1)$和$B(x_2, y_2)$
\begin{itemize}
	\item $x_1\equiv x_2\pmod{p}, y_1\equiv -y_2\pmod{p}$
	\[A+B=O\]
	\item $\pth{x_1, y_1}\not\equiv\pth{x_2, -y_2}\mod{c}$
	\begin{gather}
	x_{A+B}=\lambda^2-x_1-x_2\bmod{p}\\
	y_{A+B}=\lambda\pth{x_1-x_3}-y_1\bmod{p}
	\end{gather}

	其中
	\begin{equation}
	\lambda=\begin{dcases}\pth{y_2-y_1}\cdot\pth{x_2-x_1}^{-1}&\pth{x_1, y_1}\not\equiv \pth{x_2, y_2}\pmod{p}\\\pth{3x_1^2+a}\cdot\pth{2y_1}^{-1}&\pth{x_1, y_1}\equiv\pth{x_2, y_2}\pmod{p}\end{dcases}
	\end{equation}
\end{itemize}

$E_p\pth{a, b}$上的数乘运算即为：$n$个点$A$相加$A+A+\cdots +A=nA$.\par
而Hasse定理则阐述了一件事：
\begin{theorem}
设$N$为$E_p\pth{a,b}$元素的个数，那么
\begin{equation}
\abs{N-\pth{q-1}}\leq 2\sqrt{q}
\end{equation}
\end{theorem}

从而我们得知，$E_p\pth{a, b}$是一个有限群。\par
又由另一个定理：素数阶的有限群是循环群，因此，如果$N$为素数，那么$E_p\pth{a, b}$为循环群。NIST组织提供了一组供密码学使用的椭圆曲线，保证其一定能够构成一个循环群。
\subsubsection{明文映射到椭圆曲线群}
对于二进制串的明文，设其对应的二进制数为$m$，选取一个充分大的整数$k$(该整数也属于公钥中的一部分)。令
\[x=mk+j\]
其中$j$从0开始，不断自增1，直到在$E_p\pth{a, b}$中存在一点$\pth{x_0, y_0}$, 使得$x_0=x$, 那么就将该点看作明文映射的对应元素。
\subsubsection{椭圆曲线群映射到明文}
对于点$\pth{x, y}$和公钥中的整数$k$, 计算
\[m=\lfloor \frac{x}{k} \rfloor\]
即可。
\subsection{椭圆曲线上的ElGamal}
在介绍了循环群$E_p\pth{a, b}$之后，我们可以将其应用到ElGamal密码上。对其基本框架作如下修改：
\subsubsection{公钥-私钥生成}
\begin{enumerate}
	\item 选取一个构成循环群的生成元为$P$的$N$阶椭圆曲线群$E_p\pth{a, b}$
	\item 选取一个足够大的整数$k$, 构成明文、椭圆曲线群之间的映射
	\item 从$1$到$N-1$之间选择一个整数$x$
	\item 计算$Y=xP$
	\item 公钥为$\pth{E_p\pth{a, b}, P, N, Y, k}$, 私钥为$x$
\end{enumerate}
\subsubsection{加密}
\begin{enumerate}
	\item 从$1$到$N-1$之间选择一个整数$y$
	\item 计算$C=yP, C'=yY$
	\item 将明文$m$映射到$E_p\pth{a, b}$上的点$P_m$
	\item 密文为$\pth{C, C'+P_m}$
\end{enumerate}
\subsubsection{解密}
\begin{enumerate}
	\item 计算$C'=xC$
	\item 计算$P_m=C'+P_m+\pth{-C'}$
	\item 将$P_m$映射回$m$即为明文
\end{enumerate}